/**
 * @file src/core/Simulator.java
 * @brief Orchestrates the end-to-end telecom traffic simulation workflow.
 * @details The simulator glues together configuration, event scheduling,
 *          traffic-source evolution, statistics sampling, and output export.
 *          Responsibilities span initializing {@link model.TrafficSource}
 *          instances (Pareto or FGN), advancing the {@link core.EventQueue},
 *          synchronizing with the {@link core.SimulationClock}, running an
 *          optional {@link extensions.NetworkQueue}, and writing structured
 *          artifacts through {@link io.OutputSink}. Inputs include
 *          {@link model.SimulationParameters} and the events generated by each
 *          source. Outputs are time-series samples, event logs, and summaries.
 *          Collaborators: {@link extensions.MultiSourceManager},
 *          {@link core.StatisticsCollector}, {@link io.FileOutputManager}, and
 *          {@link io.ErrorHandler} for resilient execution.
 * @date 2024-05-30
 */
package core;

import model.*;
import util.RandomUtils;
import io.FileOutputManager;
import io.OutputSink;
import extensions.MultiSourceManager;
import extensions.NetworkQueue;
import io.ErrorHandler;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;

import java.util.ArrayList;
import java.util.List;

/**
 * @class Simulator
 * @brief High-level controller for the event-driven simulation engine.
 * @details Acts as the single entry point for running experiments. It
 *          initializes traffic models, schedules events, consumes them in
 *          chronological order, updates aggregate statistics, and persists
 *          results. The simulator consumes {@link SimulationParameters} and
 *          produces CSV/summary outputs plus queue analytics. It collaborates
 *          with {@link EventQueue}, {@link SimulationClock},
 *          {@link StatisticsCollector}, and IO helpers.
 */
public class Simulator {

    /** Immutable parameters describing the run. */
    private final SimulationParameters params;
    /** Duration of the experiment in seconds. */
    private final double totalSimulationTime;
    /** Total number of ON/OFF sources participating. */
    private final int numSources;

    /** Shared event priority queue. */
    private final EventQueue eventQueue;
    /** Global simulation clock. */
    private final SimulationClock clock;
    /** Collector that stores sampled aggregate rates. */
    private final StatisticsCollector stats;
    /** Supplier for producing run-specific output sinks. */
    private final Supplier<OutputSink> outputSinkSupplier;
    /** Factory responsible for creating multiple sources. */
    private final MultiSourceManager multiSourceManager;
    /** Optional downstream queue to approximate congestion. */
    private final NetworkQueue networkQueue;

    /** All instantiated traffic sources. */
    private final List<TrafficSource> sources = new ArrayList<>();

    /**
     * Next regularly spaced sampling instant for recording the aggregate rate.
     * Sampling at fixed intervals better matches the requirement of exporting a
     * uniformly spaced time-series instead of sampling only when events occur.
     */
    private double nextSampleTime = 0.0;

    /** Tracks the most recent aggregate rate applied to sampling. */
    private double lastRecordedRate = 0.0;

    /**
     * @brief Constructs a simulator using the provided configuration.
     * @param params Immutable snapshot of user-provided simulation settings.
     */
    public Simulator(SimulationParameters params) {
        this(params, () -> new FileOutputManager(defaultMetadata(params)));
    }

    /**
     * @brief Dependency-injection friendly constructor for supplying sinks.
     * @param params Simulation settings shared with all subsystems.
     * @param outputSinkSupplier Factory invoked per run to create an
     *                           {@link OutputSink} implementation (file-based
     *                           or test double).
     */
    public Simulator(SimulationParameters params, Supplier<OutputSink> outputSinkSupplier) {
        this.params = params;
        this.totalSimulationTime = params.totalSimulationTime;
        this.numSources = params.numberOfSources;
        this.outputSinkSupplier = Objects.requireNonNull(outputSinkSupplier, "outputSinkSupplier");

        this.eventQueue = new EventQueue();
        this.clock = new SimulationClock();
        this.stats = new StatisticsCollector(params.samplingInterval);

        // Initialize managers
        this.multiSourceManager = new MultiSourceManager();
        this.networkQueue = new NetworkQueue(5.0); // Example service rate Âµ = 5 pkt/s

        // === Initialize sources ===
        if (params.trafficModel == SimulationParameters.TrafficModel.FGN_THRESHOLD) {
            // Alternative model using Fractional Gaussian Noise-based thresholds
            sources.addAll(multiSourceManager.generateFGNSources(params));
        } else {
            // Default Pareto-based ON/OFF sources
            sources.addAll(
                    multiSourceManager.generateSources(numSources,
                            params.onShape, params.onScale,
                            params.offShape, params.offScale,
                            0.15)
            );
        }

        // Schedule each source's first ON event at a small random offset
        for (int i = 0; i < sources.size(); i++) {
            double offset = RandomUtils.uniform(0, 5.0);
            eventQueue.addEvent(new Event(offset, i, EventType.ON));
        }

        // Initial aggregate rate (all sources start OFF).
        this.lastRecordedRate = computeAggregateRate();
    }

    /**
     * @brief Runs the simulation loop and exports data to organized outputs.
     * @details The method drains the {@link EventQueue} while the
     *          {@link SimulationClock} is below {@link #totalSimulationTime}.
     *          For each event it updates the corresponding source, schedules the
     *          next event, captures samples, and writes to the {@link OutputSink}.
     *          At completion the method finalizes queue statistics and exports
     *          CSV plus summaries.
     */
    public void run() {
        System.out.println("Starting simulation...");

        try (OutputSink outputManager = outputSinkSupplier.get()) {
            String runDir = outputManager.getRunDirectory();

            while (!eventQueue.isEmpty() && clock.getTime() < totalSimulationTime) {
                Event event = eventQueue.nextEvent();
                if (event == null) break;

                double eventTime = event.getTime();
                recordSamplesBefore(Math.min(eventTime, totalSimulationTime));

                clock.advanceTo(eventTime);
                if (clock.getTime() > totalSimulationTime) break;

                try {
                    // Process source event
                    TrafficSource src = sources.get(event.getSourceId());
                    src.processEvent(event);

                    // Log to event log
                    outputManager.logEvent(event);

                    // Schedule next state-change event
                    Event next = src.generateNextEvent(clock.getTime());
                    eventQueue.addEvent(next);

                    // Update aggregate rate for future sampling
                    lastRecordedRate = computeAggregateRate();

                } catch (Exception e) {
                    ErrorHandler.handleError("Error processing event: " + e.getMessage(), false);
                }
            }

            // Capture any remaining samples through the end of the simulation window
            recordRemainingSamples();
            networkQueue.processUntil(totalSimulationTime);

            System.out.println("Simulation complete!");
            stats.printSummary();

            // === Export clean, organized outputs ===
            stats.exportToCSV(runDir + "traffic_data.csv");
            outputManager.saveSummary(stats, networkQueue);

            System.out.printf("Results saved to: %s%n", runDir);
        }
    }

    /**
     * @brief Builds the metadata map injected into {@link FileOutputManager}.
     * @param params Parameters describing the active simulation run.
     * @return Ordered map ready to be persisted alongside outputs.
     */
    private static Map<String, String> defaultMetadata(SimulationParameters params) {
        Map<String, String> metadata = new LinkedHashMap<>();
        metadata.put("mode", params.trafficModel.name());
        metadata.put("sources", Integer.toString(params.numberOfSources));
        metadata.put("simulationTime", Double.toString(params.totalSimulationTime));
        metadata.put("samplingInterval", Double.toString(params.samplingInterval));
        return metadata;
    }

    /**
     * @brief Computes the aggregate ON fraction across all sources.
     * @return Fraction of traffic sources currently emitting packets.
     */
    private double computeAggregateRate() {
        if (numSources == 0) return 0.0;
        long onCount = sources.stream().filter(TrafficSource::isOn).count();
        return (double) onCount / numSources;
    }

    /**
     * @brief Records samples at fixed intervals before the provided cutoff.
     * @details The aggregate rate is piecewise constant between events, so the
     *          method reuses {@link #lastRecordedRate} until the next event.
     *          During each interval the associated {@link extensions.NetworkQueue}
     *          is advanced and fed with approximate arrivals.
     * @param cutoffTime Upper bound (exclusive) for sample timestamps.
     */
    private void recordSamplesBefore(double cutoffTime) {
        if (params.samplingInterval <= 0) {
            ErrorHandler.handleError("Sampling interval must be positive", true);
        }
        while (nextSampleTime < cutoffTime && nextSampleTime <= totalSimulationTime) {
            networkQueue.processUntil(nextSampleTime);
            int arrivals = (int) Math.round(lastRecordedRate * numSources);
            if (arrivals > 0) {
                networkQueue.enqueueBulk(nextSampleTime, arrivals);
            }
            stats.recordSample(nextSampleTime, lastRecordedRate);
            nextSampleTime += params.samplingInterval;
        }
    }

    /**
     * @brief Records samples until the global simulation time limit is reached.
     * @details Invoked after the event loop drains to ensure the output CSV is
     *          complete through {@link #totalSimulationTime}. Maintains the same
     *          piecewise-constant assumption as {@link #recordSamplesBefore(double)}.
     */
    private void recordRemainingSamples() {
        if (params.samplingInterval <= 0) return;
        while (nextSampleTime <= totalSimulationTime) {
            networkQueue.processUntil(nextSampleTime);
            int arrivals = (int) Math.round(lastRecordedRate * numSources);
            if (arrivals > 0) {
                networkQueue.enqueueBulk(nextSampleTime, arrivals);
            }
            stats.recordSample(nextSampleTime, lastRecordedRate);
            nextSampleTime += params.samplingInterval;
        }
    }
}
